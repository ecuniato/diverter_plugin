#include <ros/ros.h>
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/Plugin.hh>
#include "geometry_msgs/WrenchStamped.h"
#include "geometry_msgs/PoseStamped.h"
#include <eigen3/Eigen/Dense>
#include <eigen3/Eigen/Core>
#include <tf/tf.h>
#include <tf_conversions/tf_eigen.h>

using namespace Eigen;
using namespace std;

//Keeps track if we are not in contact and under the power line (UNDER),
// if we are currently attached to the line (HOOKED), or if we are not in contact and over the line (OVER)
enum State {NONE, UNDER, HOOKED, OVER};
#define Z_CABLE 1.0 //Absolute altitude of the power line where to attach the diverter (position of the spring)

namespace gazebo
{
  class DiverterPlugin : public WorldPlugin
  {

	private: ros::NodeHandle* _nh;
  private:
     ros::Publisher _force_pub;
     ros::Subscriber _pose_sub;
     ros::Subscriber _dronepose_sub;
     double _Kp;
     bool forceOn;
     Vector4d _a;
     double _forceNorm, _zpos, _zarm, _zdrone;
     Matrix3d _Rsensor;
     State _state;
     event::ConnectionPtr updateConnection;
     physics::WorldPtr _world;
     physics::ModelPtr _model;
    gazebo::physics::LinkPtr _link;
    bool _firstcb;
  public:
   void pose_cb( geometry_msgs::PoseStampedConstPtr );
   void dronepose_cb( geometry_msgs::PoseConstPtr );
   void ctrl_loop();
   void OnUpdate();
	 void Load(physics::WorldPtr world, sdf::ElementPtr _sdf) {
		_nh = new ros::NodeHandle();
    _world = world;
    ROS_WARN("Bird diverter force plugin started!");
    _pose_sub = _nh->subscribe("/iiwa/eef_pose", 0, &DiverterPlugin::pose_cb, this);
    _dronepose_sub = _nh->subscribe("/hummingbird/ground_truth/pose", 0, &DiverterPlugin::dronepose_cb, this);
    _force_pub = _nh->advertise< geometry_msgs::WrenchStamped>("/netft_data", 0);

    _Kp = 7500;
    forceOn=false;
    _state = NONE;
    _forceNorm = 0;
    boost::thread ctrl_loop_t( &DiverterPlugin::ctrl_loop, this);
    _zpos=_zarm=_zdrone=0;
    _firstcb=false;
	 }

  };

  void DiverterPlugin::ctrl_loop() {
    double freq = 500; //update rate of the simulation
    double dt = 1.0/freq;
    ros::Rate r(freq);

    
    Vector3d sensorForce;
    geometry_msgs::WrenchStamped sensor_wrench;

    while(!_firstcb) sleep(1);

    while(ros::ok()) {
      sensor_wrench.wrench.force.x = 0;
      sensor_wrench.wrench.force.y = 0;
      sensor_wrench.wrench.force.z = 0;

      while(!forceOn) { //The force added on the drone's arm tip is zero (not in contact)
        sensor_wrench.header.stamp = ros::Time::now();
        _force_pub.publish(sensor_wrench);
        _link->AddForce(ignition::math::Vector3d(0,0,0)); //for global force
        r.sleep();
      }

      while(forceOn) { //We are in contact with the power line
        _forceNorm = _Kp * abs(_zpos - Z_CABLE); //Force along z world axis, like generated by a spring
        sensorForce = _Rsensor.transpose() * Vector3d(0,_forceNorm/2,-_forceNorm); //Experimentally, I put the whole force along Z and half of that along the axis perpendicular to the cable.
        //In the experiments I had around ~30N in the Z axis and ~15N in the perpendicular axis. I tuned the _Kp gain so that the simulated force is similiar.
        sensor_wrench.wrench.force.x = sensorForce[0];
        sensor_wrench.wrench.force.y = sensorForce[1];
        sensor_wrench.wrench.force.z = sensorForce[2];
        sensor_wrench.header.stamp = ros::Time::now();
        _force_pub.publish(sensor_wrench); //We publish the force as measured by the force sensor

        _link->AddForce(ignition::math::Vector3d(0,_forceNorm/2,-_forceNorm)); //We apply the force on the object in simulation
        r.sleep();
      }

    }

  }

  //Callback to obtain the position of the drone.
  void DiverterPlugin::dronepose_cb( geometry_msgs::PoseConstPtr pos ) {
    _zdrone = pos->position.z;

    if(!_firstcb) {
      // Get model
      _model = _world->ModelByName("hummingbird");
      if(_model == NULL) {
        ROS_WARN("Model not found!");
        return;
      }
      _link = _model->GetChildLink("Roll_1");
      if(_link == NULL) {
        ROS_WARN("Link not found!");
        return;
      }

      ROS_WARN("Link obtained!");
    }
    _firstcb=true;
  }

  //Callback to obtain the position of the arm tip (here referred as sensor, like force sensor)
  //We need both the position of the arm and the one of the drone to see if we are in contact with the power line or not.
  void DiverterPlugin::pose_cb( geometry_msgs::PoseStampedConstPtr pos ) {
      _zarm = pos->pose.position.z;
      _zpos = _zarm + _zdrone;
      
      tf::Quaternion qsensor(pos->pose.orientation.x,pos->pose.orientation.y,pos->pose.orientation.z,pos->pose.orientation.w);
      tf::Matrix3x3 Rsensor(qsensor);
      tf::matrixTFToEigen(Rsensor,_Rsensor); //Rotation matrix of the arm tip w.r.t. the arm base (which corresponds to the drone base)

      switch(_state) {
        case NONE: //Just the starting state. It's practically useless.
          if(_zpos>=Z_CABLE) _state = OVER;
          else if (_zpos<Z_CABLE) _state = UNDER;
          break;
        case UNDER: //We are under the line
          if(_zpos>=Z_CABLE) {
            forceOn = true;
            _state = HOOKED;
            ROS_WARN("HOOKING!");
          }
          break;
        case HOOKED: //We are in contact with the power line
          if(_forceNorm>40) { //If the forceNorm goes over 40N, then we consider the diverter Hooked to the line and detached from the drone. We stop applying forces on the drone
            forceOn = false;
            _state = OVER;
            ROS_WARN("Diverter HOOKED: OVER!");
          }
          else if (_zpos<Z_CABLE) { //Or if we bounce back then we go into the UNDER state again
            forceOn = false;
            _state = UNDER;
            ROS_WARN("UNDER!");
          }
          break;
        case OVER:
          if(_zpos<(Z_CABLE-0.02)) { //If we go under the cable then we go into the UNDER state again
            _state = UNDER;
            ROS_WARN("UNDER!");
          }
          break;
      }

  }

  // Register this plugin with the simulator
  GZ_REGISTER_WORLD_PLUGIN(DiverterPlugin)
}